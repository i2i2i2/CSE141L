module op_17;

// A = {r1, r0}	   (16 bits)
// B = r2          ( 8 bits)
// copy B to branch, then use for r2 for product
// B = r_br        ( 8 bits)
// r_acc = accumulator
// P = {r3, r2}    (16 bits)
logic[7:0] r1, r0, r_br, r_acc, r3, r2;
//logic[8:0] alu_out;
logic      ov;
logic[15:0]      A ;
logic[ 7:0]      B ; 
initial begin
  for(int j=0; j<15; j++) begin
	{B,A[7:0]} = $random;
	A[15:8] = 0;
  r3 = 0;
  r2 = B;
  r_acc = 0;
  r1 = A[15:8];
  r0 = A[ 7:0];
  r_br  = r2;
  #10ns;
  if(r_br[0]) begin
    {ov, r2} = r0;
	{ov, r3} = r1;
  end
  else begin
    {ov, r2} = 0;
	{ov, r3} = 0;
  end
  for(int i=0; i<7; i++) begin
    #10ns;
    r_acc      = r0;
    {ov,r0}    = {r_acc[7:0],1'b0};	   // r_acc<<1
    r_acc      = r1;
    r1         = {r_acc[6:0],ov};
    r_br       = r_br[7:1];
    if(r_br[0]) begin
      r_acc    = r2;
	  ov       = 0;
      {ov, r2} = {1'b0,r_acc} + {1'b0,r0} + ov;   // ov=0 for LSBs
      r_acc    = r3;  
      {ov, r3} = {1'b0,r_acc} + {1'b0,r1} + ov;	  // ov will get cleared after
	  ov       = 0;
    end
  end
  #10ns;
  $display(A,,,,B,,,,A*B,,,{r3,r2});
//  if(A*B != {r3,r2})
//    $display(barf!);
end
end

endmodule