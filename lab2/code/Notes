Ports
  input // output // inout
ex:
  input[7:0] addr;      // addr 8-bit input

Data Type:
  In hardware only 2 driver
    * Driver that store a value, ex: flip flop
    * Driver connect 2 points, ex: wire

  reg: keyword, stores one value
  wire: keyword, connects 2 points

Operations
  Arithmetic:   *, /, +, -, %
  logical:      !, &&, ||
  Relational:   >, <, >=, <=, ==, !=
  Reduction:    ~, &, ~&, |, ~|, ^, ^~(~^),
  Shift:        >>, <<
  Concat:       {}
  Conditional:  ?

  Note: ~, invertion, ! logical not

Control Statements
  If-else:
    if (enable == 1'b1) begin
      // do something
    end else begin
      // do something else
    end

  Case:
    case(addr)
      0:  // do something 0
      1:  // do something 1
      // ....
      default:  // do something default
    endcase

    case(addr)
      0: begin
        // do something 0
      end
      1: begin
        // do something 1
      end
      // ....
      default: begin
        // do something default
      end
    endcase

  while:
    while (free_time) beign
      $display("continue with webpage development");
    end

    1 module counter (clk,rst,enable,count);
    2 input clk, rst, enable;
    3 output [3:0] count;
    4 reg [3:0] count;
    5
    6 always @ (posedge clk or posedge rst)
    7 if (rst) begin
    8   count <= 0;
    9 end else begin : COUNT
   10   while (enable) begin
   11     count <= count + 1;
   12     disable COUNT;
   13   end
   14 end
   15
   16 endmodule

   Note: disable, break the loop

  for:
    for (i = 0; i < 16; i = i + 1) begin
      // do something
    end

  repeat:
    repeat(16) begin
      // do something
    end

Variable Assignment
  Initial Block:
    initial begin
      // do something
    end

  At the beginning of simulation, do such thing

Always Block
  Use sensitive list / delay to execute a code

  always @ (a or b or sel)
  begin
    y = 0
    if (sel == 0) begin
      y = a;
    end else begin
      y = b;
    end
  end

  whenever, a or b or sel change, the code execute
  2:1 mux

  always @ (posedge clk)
  if (reset == 0) begin
    y <= 0;
  end else if (sel == 0) begin
    y <= a;
  end else begin
    y <= b;
  end

  Now y is a flip flop. '=' blocking, '<=' non-blocking

  always begin
    #5  clk = ~clk;
  end

  No sensitive list, but has delay

Assign Statement: Execute continuously
  assign out = (enable) ? data: 1'bz

  This is tri state buffer

  assign out = data;
  This is simple buffer

Test Bench
  1 module arbiter (
  2 clock,
  3 reset,
  4 req_0,
  5 req_1,
  6 gnt_0,
  7 gnt_1
  8 );
  9
  10 input clock, reset, req_0, req_1;
  11 output gnt_0, gnt_1;
  12
  13 reg gnt_0, gnt_1;
  14
  15 always @ (posedge clock or posedge reset)
  16 if (reset) begin
  17  gnt_0 <= 0;
  18  gnt_1 <= 0;
  19 end else if (req_0) begin
  20   gnt_0 <= 1;
  21   gnt_1 <= 0;
  22 end else if (req_1) begin
  23   gnt_0 <= 0;
  24   gnt_1 <= 1;
  25 end
  26
  27 endmodule
  28 // Testbench Code Goes here
  29 module arbiter_tb;
  30
  31 reg clock, reset, req0,req1;
  32 wire gnt0,gnt1;
  33
  34 initial begin
  35   $monitor ("req0=%b,req1=%b,gnt0=%b,gnt1=%b", req0,req1,gnt0,gnt1);
  36   clock = 0;
  37   reset = 0;
  38   req0 = 0;
  39   req1 = 0;
  40    #5  reset = 1;
  41    #15  reset = 0;
  42    #10  req0 = 1;
  43    #10  req0 = 0;
  44    #10  req1 = 1;
  45    #10  req1 = 0;
  46    #10  {req0,req1} = 2'b11;
  47    #10  {req0,req1} = 2'b00;
  48    #10  $finish;
  49 end
  50
  51 always begin
  52   #5  clock =  ! clock;
  53 end
  54
  55 arbiter U0 (
  56 .clock (clock),
  57 .reset (reset),
  58 .req_0 (req0),
  59 .req_1 (req1),
  60 .gnt_0 (gnt0),
  61 .gnt_1 (gnt1)
  62 );
  63
  64 endmodule

Integer Data Type
  Integer data types can be classified into 2-state types and 4-state types.
  2-state types can take only 0, 1, where as 4-state types can take 0,1,X,Z. 2-state types consume less (50%) memory and simulate faster when compared to 4-state types.

  2 state value integer data types are

  shortint : 16-bit signed integer.
  int : 32-bit signed integer.
  longint : 64-bit signed integer.
  byte : 8-bit signed integer, can be used for storing ASCII charater.
  bit : User defined vector types.
  4-state value integers data types are

  logic : User defined vector types.
  reg : User defined vector types.
  wire : User defined vector types.
  integer : 32-bit signed integer.
  time : 64-bit unsigned integer.

  
