$date
	Sun May  7 06:05:44 2017
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module RegsFile_tb $end
$var wire 8 ! reg3 [7:0] $end
$var wire 8 " reg2 [7:0] $end
$var wire 8 # reg1 [7:0] $end
$var wire 1 $ flipout $end
$var wire 1 % flagout $end
$var reg 1 & CLK $end
$var reg 1 ' flagin $end
$var reg 1 ( flipin $end
$var reg 1 ) isReg1 $end
$var reg 1 * isReg2 $end
$var reg 1 + isReg3 $end
$var reg 1 , isRegW $end
$var reg 1 - isWrite $end
$var reg 3 . read1 [2:0] $end
$var reg 3 / read2 [2:0] $end
$var reg 8 0 writeData [7:0] $end
$var reg 1 1 writeFlag $end
$var reg 1 2 writeFlip $end
$var reg 3 3 writeReg [2:0] $end
$scope module registers $end
$var wire 1 & CLK $end
$var wire 1 ' flagin $end
$var wire 1 ( flipin $end
$var wire 1 ) isReg1 $end
$var wire 1 * isReg2 $end
$var wire 1 + isReg3 $end
$var wire 1 , isRegW $end
$var wire 1 - isWrite $end
$var wire 1 4 isWriteAcc $end
$var wire 1 5 isWriteReg $end
$var wire 8 6 outAcc3 [7:0] $end
$var wire 8 7 outReg3 [7:0] $end
$var wire 3 8 read1 [2:0] $end
$var wire 3 9 read2 [2:0] $end
$var wire 8 : writeData [7:0] $end
$var wire 1 1 writeFlag $end
$var wire 1 2 writeFlip $end
$var wire 3 ; writeReg [2:0] $end
$var wire 8 < reg3 [7:0] $end
$var wire 8 = reg2 [7:0] $end
$var wire 8 > reg1 [7:0] $end
$var wire 8 ? outReg2 [7:0] $end
$var wire 8 @ outReg1 [7:0] $end
$var wire 8 A outAcc2 [7:0] $end
$var wire 8 B outAcc1 [7:0] $end
$var wire 1 $ flipout $end
$var wire 1 % flagout $end
$scope module accReg $end
$var wire 1 & CLK $end
$var wire 8 C acc1 [7:0] $end
$var wire 8 D acc2 [7:0] $end
$var wire 8 E acc3 [7:0] $end
$var wire 1 4 isWrite $end
$var wire 3 F read1 [2:0] $end
$var wire 3 G read2 [2:0] $end
$var wire 8 H writeData [7:0] $end
$var wire 3 I writeReg [2:0] $end
$upscope $end
$scope module bitReg $end
$var wire 1 & CLK $end
$var wire 1 ' flagin $end
$var wire 1 % flagout $end
$var wire 1 ( flipin $end
$var wire 1 $ flipout $end
$var wire 1 1 writeFlag $end
$var wire 1 2 writeFlip $end
$var reg 1 J flag $end
$var reg 1 K flip $end
$upscope $end
$scope module regReg $end
$var wire 1 & CLK $end
$var wire 1 5 isWrite $end
$var wire 2 L read1 [1:0] $end
$var wire 2 M read2 [1:0] $end
$var wire 8 N reg1 [7:0] $end
$var wire 8 O reg2 [7:0] $end
$var wire 8 P reg3 [7:0] $end
$var wire 8 Q writeData [7:0] $end
$var wire 2 R writeReg [1:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
xK
xJ
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
x5
x4
bx 3
x2
x1
bx 0
bx /
bx .
x-
x,
x+
x*
x)
x(
x'
x&
x%
x$
bx #
bx "
bx !
$end
#50
0&
#100
b1101001 #
b1101001 >
b1101001 B
b1101001 C
b0 R
05
14
b0 L
1&
b1101001 0
b1101001 :
b1101001 H
b1101001 Q
0,
b0 3
b0 ;
b0 I
1-
0)
b0 .
b0 8
b0 F
#150
0&
#200
bx #
bx >
1&
1)
#250
0&
#300
b11110000 "
b11110000 =
b11110000 ?
b11110000 O
b1101001 #
b1101001 >
15
04
b1 R
b1 M
1&
0)
b11110000 0
b11110000 :
b11110000 H
b11110000 Q
1,
b1 3
b1 ;
b1 I
1*
b1 /
b1 9
b1 G
#350
0&
#400
bx "
bx =
1&
0*
#450
0&
#500
05
1&
0-
b1111 0
b1111 :
b1111 H
b1111 Q
0,
#550
0&
#600
1$
1K
1&
12
1(
#650
0&
#700
1&
02
0(
#750
0&
#800
b10110100 !
b10110100 <
b10110100 6
b10110100 E
14
1&
1-
b10110100 0
b10110100 :
b10110100 H
b10110100 Q
b101 3
b101 ;
b101 I
0+
#850
0&
#900
b11111100 @
b11111100 N
b11111100 7
b11111100 P
15
04
b0 R
b11111100 !
b11111100 <
1&
1,
b11111100 0
b11111100 :
b11111100 H
b11111100 Q
b0 3
b0 ;
b0 I
1+
#950
0&
#1000
1&
