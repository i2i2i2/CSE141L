$date
	Sun May  7 01:32:46 2017
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module RegsFile_tb $end
$var wire 8 ! reg3 [7:0] $end
$var wire 8 " reg2 [7:0] $end
$var wire 8 # reg1 [7:0] $end
$var wire 1 $ flipout $end
$var wire 1 % flagout $end
$var reg 1 & CLK $end
$var reg 1 ' flagin $end
$var reg 1 ( flipin $end
$var reg 1 ) isReg1 $end
$var reg 1 * isReg2 $end
$var reg 1 + isRegW $end
$var reg 1 , isWrite $end
$var reg 3 - read1 [2:0] $end
$var reg 3 . read2 [2:0] $end
$var reg 8 / writeData [7:0] $end
$var reg 1 0 writeFlag $end
$var reg 1 1 writeFlip $end
$var reg 3 2 writeReg [2:0] $end
$scope module registers $end
$var wire 1 & CLK $end
$var wire 1 ' flagin $end
$var wire 1 ( flipin $end
$var wire 1 ) isReg1 $end
$var wire 1 * isReg2 $end
$var wire 1 + isRegW $end
$var wire 1 , isWrite $end
$var wire 1 3 isWriteAcc $end
$var wire 1 4 isWriteReg $end
$var wire 3 5 read1 [2:0] $end
$var wire 3 6 read2 [2:0] $end
$var wire 8 7 writeData [7:0] $end
$var wire 1 0 writeFlag $end
$var wire 1 1 writeFlip $end
$var wire 3 8 writeReg [2:0] $end
$var wire 8 9 reg3 [7:0] $end
$var wire 8 : reg2 [7:0] $end
$var wire 8 ; reg1 [7:0] $end
$var wire 8 < outReg2 [7:0] $end
$var wire 8 = outReg1 [7:0] $end
$var wire 8 > outAcc2 [7:0] $end
$var wire 8 ? outAcc1 [7:0] $end
$var wire 1 $ flipout $end
$var wire 1 % flagout $end
$scope module accReg $end
$var wire 1 & CLK $end
$var wire 8 @ acc1 [7:0] $end
$var wire 8 A acc2 [7:0] $end
$var wire 8 B acc3 [7:0] $end
$var wire 1 3 isWrite $end
$var wire 3 C read1 [2:0] $end
$var wire 3 D read2 [2:0] $end
$var wire 8 E writeData [7:0] $end
$var wire 3 F writeReg [2:0] $end
$upscope $end
$scope module bitReg $end
$var wire 1 & CLK $end
$var wire 1 ' flagin $end
$var wire 1 % flagout $end
$var wire 1 ( flipin $end
$var wire 1 $ flipout $end
$var wire 1 0 writeFlag $end
$var wire 1 1 writeFlip $end
$var reg 1 G flag $end
$var reg 1 H flip $end
$upscope $end
$scope module regReg $end
$var wire 1 & CLK $end
$var wire 1 4 isWrite $end
$var wire 2 I read1 [1:0] $end
$var wire 2 J read2 [1:0] $end
$var wire 8 K reg1 [7:0] $end
$var wire 8 L reg2 [7:0] $end
$var wire 8 M writeData [7:0] $end
$var wire 2 N writeReg [1:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx N
bx M
bx L
bx K
bx J
bx I
xH
xG
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
bx 6
bx 5
x4
x3
bx 2
x1
x0
bx /
bx .
bx -
x,
x+
x*
x)
x(
x'
x&
x%
x$
bx #
bx "
bx !
$end
#50
0&
#100
b1101001 #
b1101001 ;
b1101001 ?
b1101001 @
b0 N
04
13
b0 I
1&
b1101001 /
b1101001 7
b1101001 E
b1101001 M
0+
b0 2
b0 8
b0 F
1,
0)
b0 -
b0 5
b0 C
#150
0&
#200
bx #
bx ;
1&
1)
#250
0&
#300
b11110000 "
b11110000 :
b11110000 <
b11110000 L
b1101001 #
b1101001 ;
14
03
b1 N
b1 J
1&
0)
b11110000 /
b11110000 7
b11110000 E
b11110000 M
1+
b1 2
b1 8
b1 F
1*
b1 .
b1 6
b1 D
#350
0&
#400
bx "
bx :
1&
0*
#450
0&
#500
04
1&
0,
b1111 /
b1111 7
b1111 E
b1111 M
0+
#550
0&
#600
1$
1H
1&
11
1(
#650
0&
#700
1&
01
0(
#750
0&
#800
1&
